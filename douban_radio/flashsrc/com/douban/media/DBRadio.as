package com.douban.media{    import flash.net.SharedObject;    import flash.net.URLRequest;    import flash.net.URLLoader;    import flash.events.Event;    import flash.events.IOErrorEvent;    import flash.events.EventDispatcher;    import flash.external.ExternalInterface;    import flash.utils.setTimeout;    import flash.utils.getTimer;    import com.adobe.serialization.json.JSON_as;    import com.douban.media.AudioPlayer;    import com.douban.event.CompleteEvent;    import com.douban.event.ProgressEvent;    import com.douban.event.PlayErrorEvent;    import com.douban.event.ListEvent;    import com.douban.event.SongEvent;    import com.douban.utils.Format;    public class DBRadio extends EventDispatcher {        public static const PLAYOUT = 'p', PLAYED = 'e', LIKE = 'r',                            BAN = 'b',     UNLIKE = 'u', NEW = 'n',                            SKIP = 's',    ADTYPE = 'T', START = 'start',                            LIST_ZERO_ERROR = 'lze',                            LIST_PARSE_ERROR = 'lpe',                            LIST_SERVER_ERROR = 'lse',                            LIST_IOERROR = 'lioe';        private var playSong;        private var player:AudioPlayer;        private var lg;        private var playList:Array = [];        private var startNewList:Boolean = true;        private var so:SharedObject;        private var loader:URLLoader, repLoader:URLLoader;        private var reportedId:String;        private var _channel:String = '1';        private var HOST:String, LISTURL:String;        private var timeToWait:int = 0, requrl:String;        private var context:String;        private var pauseTime = 0;        public function DBRadio(host, contextStr, logger) {            HOST = host;            context = contextStr;            lg = logger;            LISTURL = host + '/j/mine/playlist';            player = new AudioPlayer(lg);            player.addEventListener(CompleteEvent.COMPLETE, onComplete)            player.addEventListener(PlayErrorEvent.PLAY_ERROR, onPlayError)            player.addEventListener(ProgressEvent.PROGRESS, onProgress)            so = SharedObject.getLocal('douban_radio','/');            if (so.data.history == undefined) {                so.clear();                so.data.history = '';                so.flush();            }            loader = new URLLoader();            loader.addEventListener(IOErrorEvent.IO_ERROR, loader_ioError);            loader.addEventListener(Event.COMPLETE, listOnload);            repLoader = new URLLoader();            repLoader.addEventListener(IOErrorEvent.IO_ERROR, report_ioError);            ExternalInterface.addCallback('list_onload', jsListOnload);            ExternalInterface.addCallback('list_onerror', loader_ioError);        }        public function start() {            if (player.status == AudioPlayer.PLAY) {                return;            }            requireList(null, NEW);        }        public function pause() {            pauseTime = getTimer();            player.pause();        }        public function resume() {            player.play();            if ((getTimer() - pauseTime) / 1000 > 60 * 30){                playList = [];                requireList(null, NEW);            }        }        public function like() {            playSong.like = true;            startNewList = false;            onStatus(LIKE);        }        public function unlike() {            playSong.like = false;            startNewList = false;            onStatus(UNLIKE);        }        public function get isLiked(){            return playSong && playSong.like;        }        public function ban() {            onStatus(BAN)            playNext();        }        public function skip() {            onStatus(SKIP);            playNext();        }        public function onAdjustVolume(e)        {            player.volume = e.percent;        }        public function set volume(v) {            player.volume = v;        }        public function get volume(){            return player.volume;        }        public function set channel(ch) {            if (ch !== _channel) {                _channel = ch;                if (player.status === AudioPlayer.PLAY) {                    playList = [];                    requireList(null, NEW);                    playNext();                }            }        }        public function get channel() {            return _channel;        }        private function onStatus(type) {            var songEv = new SongEvent;            songEv.data = {'type': type, 'song': playSong, 'channel': _channel}            dispatchEvent(songEv);            if (playSong['subtype'] != ADTYPE) {                var sid = playSong.sid;                var history = String(so.data.history).split('|');                var f = function(ele, ind, arr){return parseInt(ele) != parseInt(sid)};                history = history.filter(f);                history.push(sid + ':' + (type == PLAYED ? PLAYOUT : type));                so.data.history = history.slice(-20).join('|');                so.flush();            }            if (type == PLAYED) {                var repurl = LISTURL+'?type=e&sid=' + playSong.sid + '&channel=' + _channel;                repurl = Format.signUrl(repurl);                lg.log('report to', repurl);                try {                    repLoader.load(new URLRequest(repurl));                } catch(e) {                    report_ioError(e);                }            } else {                requireList(playSong.sid, type);            }            if ([LIKE, UNLIKE, BAN, SKIP].indexOf(type) != -1) {                playList = [];            }        }        private function playNext() {            player.stop();            if (playList.length >= 1) {                playSong = playList.shift();                lg.log('now start to play:', playSong.title, playSong.artist, playSong.sid);                if(playList.length === 0) {                    requireList(playSong.sid, PLAYOUT);                }                var songEv = new SongEvent;                songEv.data = {'type': START, 'song': playSong, 'channel': _channel}                dispatchEvent(songEv);                player.play(playSong.url, playSong.len);            } else {                // want to play, but have to wait.                startNewList = true;            }        }        private function requireList(sid, type) {            var h = String(so.data.history);            requrl = LISTURL + '?type=' + type                             + (type != NEW ? '&sid=' + sid : '')                             + '&h=' + h                             + '&channel=' + _channel;            if (context != '') {                requrl += '&context=' + context;                context = '';            }            requrl = Format.signUrl(requrl);            lg.log('now loading:', requrl);            try {                loader.close();            } catch (e) {                //lg.log(e.message);            }            loader.load(new URLRequest(requrl));        }        private function waitTime()        {            timeToWait = timeToWait * 2 + 1;            return timeToWait;        }        private function loader_ioError(e):void        {            var ev = new ListEvent;            ev.message = {'error': LIST_IOERROR, 'msg': ''};            dispatchEvent(ev);            var wTime = waitTime();            if (wTime == 5) {                lg.report('always_load_fail ', 'ra005');                if (ExternalInterface.call('DBR.radio_getlist',requrl) != 0) {                    lg.log('now use js to try');                    return;                } else {                    lg.log('js not avail');                }            }            lg.log('retry in ' + wTime + ' secs');            var f = function(){                try{ loader.close(); } catch(e){}                loader.load(new URLRequest(requrl))};            setTimeout(f, wTime * 1000);        }        private function listOnload(e)        {            processList(loader.data);        }        public function jsListOnload(list)        {            processList(list);        }        private function processList(listData)        {            var ev = new ListEvent;            try {                var songJson = JSON_as.decode(listData);                if (typeof songJson != 'object') {                    throw new Error;                }            } catch (e) {                loader_ioError('json_parse_error');                lg.log('json parse error:' + e.toString());                ev.message = {'error': LIST_PARSE_ERROR, 'msg': 'Playlist parse error'};                dispatchEvent(ev);                return;            }            var history = String(so.data.history).split('|');            var f = function(ele, ind, arr){return ele.split(':')[0]};            history = history.filter(f);            lg.log('new list loaded...');            var error = songJson['err'];            if (error != undefined) {                lg.log('service return error:' + error);                ev.message = {'error': LIST_SERVER_ERROR, 'msg': error};                dispatchEvent(ev);                return;            }            var showtip = songJson.showtip;            if (showtip != undefined) {                ev.message = {'showtip': showtip};                dispatchEvent(ev);            }            for (var i=0; i<songJson.song.length; i++) {                var song = songJson.song[i];                if (history.indexOf(String(song.sid)) == -1) {                    lg.log('['+song.title+' / '+song.artist+' ('+song.sid+')]');                    playList.push({'sid':song.sid,'url':song.url,                      'artist':song.artist,'title':song.title,                      'picture':song.picture, 'album':song.album,                      'albumtitle':song.albumtitle, 'like':song.like == '1',                      'aid':song.aid, 'subtype':song.subtype, 'len':int(song.length)                    });                }            }            if (playList.length > 0) {                timeToWait = 0;                if (startNewList) {                    startNewList = false;                    playNext();                }            } else {                ev.message = {'error': LIST_ZERO_ERROR, 'msg': 'No song in list'};                dispatchEvent(ev);                loader_ioError('zero_song');                return;            }        }        private function onComplete(e) {            onStatus(PLAYED);            playNext();        }        private function onPlayError(e) {            switch(e.error) {                case PlayErrorEvent.ERROR_IOERROR:                    if (playList.lenth <= 1) {                        requireList(playSong.sid, PLAYOUT);                    }                    playNext();                    break;                case PlayErrorEvent.ERROR_LOAD_TIMEOUT:                    if (playList.lenth <= 1) {                        requireList(playSong.sid, PLAYOUT);                    }                    playNext();                    break;                case PlayErrorEvent.ERROR_BUFFERING:                    if (reportedId != playSong.sid) {                        lg.report('play_slow ' + playSong.url, 'ra008');                        reportedId = playSong.sid;                    }                    break;                }        }        private function report_ioError(e:IOErrorEvent):void        {            lg.log('fail when reporting:' + e.toString());        }        private function onProgress(e) {            var ev = new ProgressEvent;            ev.progress = e.progress;            dispatchEvent(ev);        }    }}